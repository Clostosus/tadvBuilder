{
  "version": 3,
  "sources": ["../src/builder/Scene.js", "../src/builder/Story.js", "../src/builder/SaveLoad.js", "../src/builder/main.js"],
  "sourcesContent": ["/**\n * Represents a single scene (node) in the story tree.\n * Each scene has narrative text, a list of choices (edges to other scenes),\n * and a reference to its parent scene. The root scene has a null parent.\n */\nexport default class Scene {\n    /**\n     * Root scene constructor.\n     * @param {string} key - Unique scene identifier.\n     * @param {string} text - Narrative text.\n     * @param {Scene|null} parent - Parent scene, or null for root.\n     * @param {Array<{text: string, next: string}>|Map<string, string>|null} choices - List of choices or null for leaf.\n     */\n    constructor(key, text = '', parent = null, choices = null)\n    {\n        this.key = key;\n        this.text = text;\n        this.parent = parent;\n        this.choices = new Map();\n\n        if (choices instanceof Map) {\n            for (const [next, choiceText] of choices) {\n                this.choices.set(next, choiceText);\n            }\n        } else if (Array.isArray(choices)) {\n            for (const c of choices) {\n                if (c.next && c.text) this.choices.set(c.next, c.text);\n            }\n        }\n    }\n\n\n    /**\n     * Adds a new choice (link) to another scene.\n     * @param {string} text - Description of the choice.\n     * @param {string} next - ID of the next scene.\n     * @returns {boolean} True if added successfully, false if duplicate key exists.\n     */\n    addChoice(text, next)\n    {\n        if (this.choices.has(next)) return false;\n        this.choices.set(next, text);\n        return true;\n    }\n\n    /**\n     * Updates the text of an existing choice.\n     * @param {string} next - Target scene ID.\n     * @param {string} newText - New description text.\n     * @returns {boolean} True if updated, false if not found.\n     */\n    updateChoice(next, newText) {\n        if (!this.choices.has(next)) return false;\n        this.choices.set(next, newText);\n        return true;\n    }\n\n    /**\n     * Removes a choice by its next key.\n     * @param {string} next - Target scene ID.\n     * @returns {boolean} True if removed, false if not found.\n     */\n    removeChoice(next) { return this.choices.delete(next); }\n\n    /**\n     * Returns all choices as an array of plain objects.\n     * @returns {Array<{text: string, next: string}>} List of choices.\n     */\n    getAllChoices()\n    {\n        return Array.from(this.choices, ([next, text]) => ({ text, next }));\n    }\n\n    /**\n     * Creates a new Scene instance from a JSON text.\n     * @returns {Scene | null} New Scene instance or null if parsing fails.\n     * @param {string} key\n     * @param {object|string} json\n     */\n    static fromJson(key,json)\n    {\n        if (!key || !json) return null;\n\n        let parsedObject = null;\n        // accept both raw string or parsed object\n        if (typeof json === 'string') {\n            try {\n                parsedObject = JSON.parse(json);\n            } catch (e) {\n                console.error(`Failed to parse JSON for scene ${key}: ${e}`);\n                return null;\n            }\n        } else if (typeof json === 'object') {\n            parsedObject = json;\n        } else {\n            console.error(`Failed to parse JSON for scene ${key}: Invalid JSON type`);\n            return null;\n        }\n        \n        if(!parsedObject.text || typeof parsedObject.text !== 'string'){\n            console.error(`Scene ${key} missing text property.`);\n            return null;\n        }\n\n        const scene = new Scene(key, parsedObject.text, null,[]);\n\n        // handle optional choices (leaf scenes may have none)\n        if (Array.isArray(parsedObject.choices)) {\n            for (const c of parsedObject.choices) {\n                if (!c || typeof c.text !== 'string' || typeof c.next !== 'string') continue;\n                scene.addChoice(c.text, c.next);\n            }\n        }\n\n        return scene;\n    }\n\n    /**\n     * Converts the scene into a plain JSON-compatible object.\n     * @returns {{text: string, choices: Array<{text: string, next: string}>}}\n     */\n    toJSON()\n    {\n        const choicesArray = [];\n        for (const [next, text] of this.choices.entries()) {\n            choicesArray.push({ text, next });\n        }\n        if(choicesArray.length === 0){\n            return { text: this.text };\n        }\n        return { text: this.text, choices: choicesArray };\n    }\n}\n\n/**\n * @typedef {Object} SceneRef\n * @property {Scene|null} scene - The referenced Scene instance, or null if missing.\n * @property {string} key - The scene key (ID)\n * @property {number} depth - Depth in the DFS traversal of the story tree, starting at 0 for the root scene.\n */", "/**\n * Represents the entire story as an object-oriented tree of scenes.\n * Controls all scenes and ensures proper parent-child relationships.\n * Each scene (except the root) must have exactly one parent.\n */\nexport default class Story {\n    /**\n     * @constructor\n     * @param {Class} sceneClass - Class representing a Scene.\n     */\n    constructor(sceneClass)\n    {\n        this.sceneClass = sceneClass;\n        this.scenes = new Map(); // key -> Scene\n        this.root = null;        // start scene\n    }\n\n    /**\n     * Adds an existing Scene instance to the story.\n     * @param {Scene} scene - Scene object to add.\n     * @returns {boolean} True if added, false if duplicate Key.\n     */\n    addScene(scene)\n    {\n        if (!(scene instanceof this.sceneClass)) return false;\n        if (this.scenes.has(scene.key)) return false;\n\n        this.scenes.set(scene.key, scene);\n        if (!this.root) {\n            this.root = scene;\n            return true;\n        } // first scene becomes root\n\n        if (!scene.parent && this.root && this.scenes.size > 0) {\n            const parent = this.findParent(scene.key);\n            if (parent) {\n                scene.parent = parent;\n                parent.addChoice(scene.text || `to ${scene.key}`, scene.key);\n            } else {\n                this.root.addChoice(scene.text || `to ${scene.key}`, scene.key);\n                scene.parent = this.root;\n            }\n        }\n\n        // ensure parent linkage integrity\n        if (scene.parent && this.scenes.has(scene.parent.key)) {\n            const parent = this.scenes.get(scene.parent.key);\n            parent.addChoice(scene.text || `to ${scene.key}`, scene.key);\n        }\n\n        return true;\n    }\n\n    /**\n     * Finds the parent Scene whose choices reference the given scene key.\n     * @param {string} sceneKey - Key of the scene to find a parent for.\n     * @returns {Scene|null} The parent Scene, or null if not found.\n     */\n    findParent(sceneKey) {\n        for (const scene of this.scenes.values()) {\n            if (scene.choices instanceof Map && scene.choices.has(sceneKey)) {\n                return scene;\n            }\n        }\n        return null;\n    }\n\n\n    /**\n     * Retrieves a scene by key.\n     * @param {string} key\n     * @returns {Scene|null}\n     */\n    getScene(key) { return this.scenes.get(key) || null; }\n\n    /**\n     * Depth of a scene relative to the root scene.\n     * @param {Scene} scene key of the scene\n     * @returns {number} depth of the scene, -1 if scene not found\n     */\n    getSceneDepth(scene) {\n        if(! this.scenes.has(scene.key)){ return -1; }\n\n        let depth = 0;\n        let current = scene;\n        while (current && current.parent) {\n            depth++;\n            current = current.parent;\n        }\n        return depth;\n    }\n\n    /**\n     * Retrieves all scene references below start scene as array in depth-first order.\n     * starting from the given scene (defaults to root).\n     * @param {Scene} [startScene=this.root]\n     * @returns {Array<SceneRef>} Array of { key, scene, depth }\n     */\n    getScenesDFS(startScene = this.root)\n    {\n        if (!startScene) return [];\n        /** @type {Array<SceneRef>} */\n        const result = [];\n        const stack = [];\n        const visited = new Set();\n\n        let baseDepth = 0;\n        if (startScene !== this.root) {\n            baseDepth = this.getSceneDepth(startScene);\n        }\n        stack.push({ scene: startScene, depth: baseDepth });\n\n        while (stack.length > 0) {\n            const { scene, depth } = stack.pop();\n\n            if(visited.has(scene.key)){ continue; }\n            visited.add(scene.key);\n            result.push({ key: scene.key, scene: scene,depth: depth });\n\n            const children = [];\n            for (const [next] of scene.choices.entries()) {\n                const child = this.getScene(next);\n                if (child) {\n                    children.push(child);\n                }else {\n                    result.push({key: next,scene: null,depth: depth + 1});\n                }\n            }\n\n            // reverse order to get initial order\n            for (let i = children.length - 1; i >= 0; i--) {\n                stack.push({ scene: children[i], depth: depth + 1 });\n            }\n        }\n        return result;\n    }\n\n    /* Content means the story text of the scene itself, and the description texts of the choices in this scene.\n     * @param {string} key\n     * @param {string} storyText\n     * @param {Map<string,string>} choiceTexts\n     * @return {boolean} true if content was edited, false if not found\n     */\n    editSceneContent(key, storyText, choiceTexts)\n    {\n        let scene = this.scenes.get(key);\n        if(!scene){\n            console.warn(`Scene ${key} not found`);\n            return false;\n        }\n        if(storyText){\n            scene.text = storyText;\n        }\n        if(choiceTexts){\n            for (const [next, text] of choiceTexts.entries()) {\n                scene.updateChoice(next, text);\n            }\n        }\n    }\n\n    /**\n     * Deletes a scene by key. Also deletes parent scene choices referencing this scene\n     * and recursively removes child scenes of this scene.\n     * @param {string} key\n     * @returns {boolean} True if found and deleted, else False\n     */\n    removeScene(key){\n        const scene = this.scenes.get(key);\n        if(!scene){\n            console.warn(`Scene ${key} not found`);\n            return false;\n        }\n\n        if(scene.parent){ scene.parent.removeChoice(scene.key); }\n\n        // Get all scenes below this scene (inclusive this one)\n        const allScenesBelow = this.getScenesDFS(scene);\n\n        // in dfs order, parents come before children\n        // To be sure that child scenes are removed before parent, we use a reverse loop:\n        for (let i = allScenesBelow.length - 1; i >= 0; i--) {\n            const { key } = allScenesBelow[i];\n            this.scenes.delete(key);\n        }\n        return true;\n    }\n\n    /**\n     * Converts the entire story into a JSON-compatible structure.\n     * Each scene key maps to an object with `text` and `choices` array.\n     * @returns {Object<string, {text: string, choices: Array<{text: string, next: string}>}>}\n     */\n    toJSON()\n    {\n        const result = {};\n        for (const [key, scene] of this.scenes.entries()) {\n            result[key] = scene.toJSON();\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new Story instance from a JSON Object.\n     * @param {Object} parsedJson\n     * @param {Class} SceneClass\n     * @returns {Story | null} New Scene instance or null if parsing fails.\n     */\n    static fromJson(parsedJson, SceneClass) {\n        if (!parsedJson || typeof parsedJson !== 'object') { return null; }\n        if (typeof SceneClass.fromJson !== 'function') {\n            console.warn('SceneClass has no method called: fromJson');\n            return null;\n        }\n\n        let story = new Story(SceneClass);\n        for (const [key, value] of Object.entries(parsedJson)) {\n            const scene = SceneClass.fromJson(key, value);\n            if (scene) {\n                story.addScene(scene);\n            }else{\n                console.warn(`Failed to load scene ${key}`);\n                return null;\n            }\n        }\n        if (story.scenes.size === 0) {\n            console.warn('No scenes found in JSON');\n            return null;\n        }\n        return story;\n    }\n}", "export default class SaveLoad {\n    constructor() {\n        throw new Error('Static class');\n    }\n\n    /**\n     * Builds the story tree from plain JSON text.\n     * @param {string} filename\n     * @param {Class} SceneClass\n     * @param {Class} StoryClass\n     * @returns {Story | null | Promise<string>} Returns new story,null deserialization fails, or Promise<string> if loading fails.\n     */\n    static async loadFromJson(filename,SceneClass, StoryClass)\n    {\n        if (!filename || typeof filename !== 'string') {\n            return null;\n        }\n        let data = null;\n        try {\n            const response = await fetch(filename);\n            if (!response.ok) {\n                return null;\n            }\n            data = await response.json();\n        } catch (e) {\n            return null;\n        }\n\n        if (typeof StoryClass.fromJson !== 'function') {\n            console.warn('StoryClass has no method called: fromJson');\n            return null;\n        }\n        return StoryClass.fromJson(data,SceneClass);\n    }\n\n    /**\n     * Saves the story tree as JSON text.\n     * @param {Story} story\n     * @param {string} filename\n     * @returns {boolean | Promise<boolean>}\n     */\n    static async saveToJson(story, filename)\n    {\n        if (!story || !filename || typeof filename !== 'string') {\n            console.error(\"Ungültige Eingabeparameter in saveToJson: story = \", story, \", filename = \", filename);\n            return false;\n        }\n\n        const data = story.toJSON();\n        try {\n            let jsonStory = JSON.stringify(data)\n            const fileBlob = new Blob([jsonStory], { type: 'text/json' });\n\n            // Create a temporary link element\n            const link = document.createElement('a');\n            link.href = URL.createObjectURL(fileBlob);\n            link.download = filename;\n            // Programmatically click the link to trigger the download\n            link.click();\n            // Clean up the URL object\n            URL.revokeObjectURL(link.href);\n\n            console.log(\"Story saved to Json\");\n        }catch(e){\n            console.error(\"Failed to save story to Json:\" + e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Saves a story as an executable HTML/CSS/JS file with which the story can be played in a browser.\n     * @param {string} filename\n     * @param {Story} story\n     * @returns {boolean | Promise<boolean>}\n     */\n    static async saveToHtml(story, filename)\n    {\n        if (!story || !filename || typeof filename !== 'string') {\n            console.error(\"Ungültige Eingabeparameter in saveToHtml: story = \", story, \", filename = \", filename);\n            return false;\n        }\n\n        // base64 encoded viewer code parts, without encoding storing them as string without unintended escaping is hard\n        // ------------------------------------------- VIEWER TEMPLATE PART 1\n        const viewerPart1 = 'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImRlIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8dGl0bGU+U3RvcnktVmlld2VyPC90aXRsZT4KICAgIDxzdHlsZT4KICAgICAgICBib2R5IHsKICAgICAgICAgICAgZm9udC1mYW1pbHk6IHN5c3RlbS11aSwgc2Fucy1zZXJpZjsKICAgICAgICB9CiAgICAgICAgaDIgewogICAgICAgICAgICBjb2xvcjogIzBmMTcyYTsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTsKICAgICAgICB9CiAgICAgICAgI2dhbWUgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjFmNWY5OwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2JkNWUxOwogICAgICAgICAgICBwYWRkaW5nOiAxcmVtOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvOwogICAgICAgICAgICBtYXgtd2lkdGg6IDgwMHB4OwogICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLDAsMCwwLjA2KTsKICAgICAgICB9CiAgICAgICAgI2dhbWUgYnV0dG9uIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzNiODJmNjsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgICAgICBwYWRkaW5nOiAwLjZyZW0gMXJlbTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4OwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIG1hcmdpbi10b3A6IDAuNXJlbTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDsKICAgICAgICB9CiAgICA8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5Pgo8ZGl2IGlkPSJnYW1lIj48L2Rpdj4KCjxzY3JpcHQ+CiAgICBjb25zdCBzdG9yeSA9IHsKICAgICAgICAvLyBJTlNFUlQgSlNPTiBTVE9SWSBIRVJFCg==';\n        // ------------------------------------------- VIEWER TEMPLATE PART 2\n        const viewerPart2 = 'ICAgIH07CgogICAgZnVuY3Rpb24gc2hvd1NjZW5lKGtleSkKICAgIHsKICAgICAgICBjb25zdCBzY2VuZSA9IHN0b3J5W2tleV07CiAgICAgICAgaWYgKCFzY2VuZSkgcmV0dXJuOwoKICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2FtZSIpOwogICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAiIjsgLy8gZGVsZXRlIHByZXZpb3VzIGNvbnRlbnQvc2NlbmUKCiAgICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJoMiIpOwogICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0ga2V5OyBjb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGUpOwoKICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicCIpOwogICAgICAgIHRleHQudGV4dENvbnRlbnQgPSBzY2VuZS50ZXh0OyBjb250YWluZXIuYXBwZW5kQ2hpbGQodGV4dCk7CgogICAgICAgIGlmICghc2NlbmUuY2hvaWNlcyB8fCBzY2VuZS5jaG9pY2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwoKICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2NlbmUuY2hvaWNlcykgewogICAgICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTsKICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gYy50ZXh0OwogICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCAoKSA9PiBzaG93U2NlbmUoYy5uZXh0KSk7CiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b24pOwogICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKSk7CiAgICAgICAgfQogICAgfQoKICAgIHNob3dTY2VuZSgic3RhcnQiKTsKPC9zY3JpcHQ+CjwvYm9keT4KPC9odG1sPg==';\n\n        const jsonObject = story.toJSON();\n        let jsonText = JSON.stringify(jsonObject);\n        jsonText = jsonText.slice(1,-1)\n\n        try {\n            const htmlText = window.atob(viewerPart1) + jsonText + window.atob(viewerPart2);\n            const fileBlob = new Blob([htmlText], { type: 'text/html' });\n\n            // Create a temporary link element\n            const link = document.createElement('a');\n            link.href = URL.createObjectURL(fileBlob);\n            link.download = filename;\n            // Programmatically click the link to trigger the download\n            link.click();\n            // Clean up the URL object\n            URL.revokeObjectURL(link.href);\n\n            console.log(\"Story saved to Html\");\n        }catch(e){\n            console.error(\"Failed to save story to Json:\" + e);\n            return false;\n        }\n        return true;\n    }\n}", "import Scene from './Scene.js';\nimport Story from \"./Story.js\";\nimport SaveLoad from \"./SaveLoad.js\";\n\n// const story = new Story();\nlet story = new Story(Scene);\n\n/**\n * Generates the story tree as an ASCII-style string.\n * Marks missing (unresolved) scenes explicitly.\n * @param {HTMLElement} parentElement Element inside which the output will be inserted.\n */\nfunction generateTreeAscii(parentElement = document.getElementById('tree-output'))\n{\n    if (!parentElement) return;\n    if (!story || !story.root) {\n        parentElement.textContent = '(noch kein Baum erstellt)';\n        return;\n    }\n\n    const scenesWithDepth = story.getScenesDFS(story.root);\n    const outputLines = [];\n    for (let i = 0; i < scenesWithDepth.length; i++) {\n        let { key, scene, depth } = scenesWithDepth[i];\n\n        // Tree-prefix (Indentation with ASCII)\n        let prefix = '';\n        for (let d = 0; d < depth; d++) {\n            prefix += (d === depth - 1) ? '|_ ' : '   ';\n        }\n        key = String(key); // ensure its string\n\n        if (scene === null) {\n            outputLines.push(prefix + '[' + key + ']' + \"(MISSING)\");\n        } else {\n            outputLines.push(prefix + key);\n        }\n    }\n    const output =  outputLines.join('\\n');\n    parentElement.textContent = output;\n}\n\n/**\n * Adds a new choice field to the choices container.\n * @returns void\n */\nfunction addChoiceField(parentElement = document.getElementById('choices-container'))\n{\n    const container = document.createElement('div');\n    container.className = 'choice-inputs';\n    container.innerHTML = `\n        <input type=\"text\" class=\"choice-text\" placeholder=\"Entscheidungstext\">\n        <input type=\"text\" class=\"choice-next\" placeholder=\"Nächste Szene (Schlüssel)\">\n      `;\n    parentElement.appendChild(container);\n}\n\n/**\n * Adds a new scene to the story.\n * @returns void\n */\nfunction addScene()\n{\n    const sceneKey = document.getElementById('scene-key').value.trim();\n    const text = document.getElementById('scene-text').value.trim();\n    if (!sceneKey || !text) return alert(\"Bitte Schlüssel und Text ausfüllen.\");\n\n    const choiceElements = document.querySelectorAll('.choice-inputs');\n    const choices = new Map();\n    choiceElements.forEach(el => {\n        const text = el.querySelector('.choice-text').value.trim();\n        const next = el.querySelector('.choice-next').value.trim();\n        if (text && next) choices.set(next, text);\n    });\n\n    story.addScene(new Scene(sceneKey, text, null, choices));\n    renderPreview(sceneKey);\n    generateTreeAscii();\n\n    // Eingabefelder leeren\n    document.getElementById('scene-key').value = \"\";\n    document.getElementById('scene-text').value = \"\";\n    const choicesContainer = document.getElementById('choices-container');\n    choicesContainer.innerHTML = `<div class=\"choice-inputs\">\n    <input type=\"text\" class=\"choice-text\" placeholder=\"Entscheidungstext\">\n    <input type=\"text\" class=\"choice-next\" placeholder=\"Nächste Szene (Schlüssel)\">\n  </div>`;\n\n    // Rückmeldung anzeigen\n    const notice = document.createElement('div');\n    notice.textContent = `✅ Szene '${sceneKey}' wurde gespeichert.`;\n    notice.style.backgroundColor = '#dcfce7';\n    notice.style.border = '1px solid #22c55e';\n    notice.style.color = '#166534';\n    notice.style.padding = '0.5rem 1rem';\n    notice.style.borderRadius = '6px';\n    notice.style.marginTop = '1rem';\n    notice.style.fontSize = '0.95rem';\n    const section = document.querySelectorAll('.section')[0];\n    section.appendChild(notice);\n    setTimeout(() => notice.remove(), 3000);\n}\n\nfunction renderPreview(key)\n{\n    const scene = story.getScene(key);\n    if (!scene) return;\n    let html = `<p><strong>${scene.key}</strong>: ${scene.text}</p>`;\n    for (const [next, text] of scene.choices.entries()) {\n        html += `<button disabled>${text} -> ${next}</button><br>`\n    }\n    document.getElementById('preview').innerHTML = html;\n}\n\nfunction startStory()\n{\n    if (!story.root) {\n        alert(\"Keine 'start'-Szene gefunden.\");\n        return;\n    }\n    renderScene(\"start\");\n}\n\nfunction renderScene(key)\n{\n    const area = document.getElementById('play-area');\n    const scene = story.getScene(key);\n    if (!scene) {\n        area.innerHTML = `<p><em>Szene '${key}' nicht gefunden.</em></p>`;\n        return;\n    }\n    let html = `<p><strong>${scene.key}</strong>: ${scene.text}</p>`;\n    for (const [next, text] of scene.choices.entries()) {\n        html += `<button onclick=\"renderScene('${next}')\">${text}</button><br>`\n    }\n    area.innerHTML = html;\n}\n\nfunction removeScene(){\n    const keyInput = document.getElementById(\"scene-key\");\n    const key = keyInput.value.trim();\n    const status = document.getElementById(\"scene-status\");\n\n    if (!key) {\n        status.textContent = \"Bitte gib den Schlüssel der zu löschenden Szene ein.\";\n        status.style.color = \"red\";\n        return;\n    }\n    if(! confirm(`Soll die Szene \"${key}\" wirklich gelöscht werden?`)){\n        return;\n    }\n    const success = story.removeScene(key);\n    if(! success){\n        status.textContent = `Keine Szene mit dem Schlüssel \"${key}\" gefunden.`;\n        status.style.color = \"orange\";\n        return;\n    }\n    status.textContent = `Szene \"${key}\" wurde erfolgreich gelöscht.`;\n    status.style.color = \"green\";\n    keyInput.value = \"\";\n    document.getElementById(\"scene-text\").value = \"\";\n    generateTreeAscii();\n}\n\n// make functions available to HTML file\nwindow.addChoiceField = addChoiceField;\nwindow.addScene = addScene;\nwindow.startStory = startStory;\n// make helper functions available\nwindow.renderPreview = renderPreview;\nwindow.renderScene = renderScene;\nwindow.removeScene = removeScene;\n\n// Register functions\nwindow.addEventListener(\"DOMContentLoaded\", (event) => {\n    console.log(\"page is fully loaded\");\n    document.getElementById(\"btnAsciiTreeRefresh\").addEventListener(\"click\", () => {\n        generateTreeAscii();  // ruft sie ohne Event-Argument auf\n    });\n});\n\n// === JSON Import/Export GUI ===\n\nconst fileInput = document.getElementById(\"json-file\");\nconst importBtn = document.getElementById(\"import-json\");\nconst exportToJsonButton = document.getElementById(\"export-json\");\nconst exportToHtmlButton = document.getElementById(\"export-html\");\nconst importStatus = document.getElementById(\"import-status\");\n\n// Reference to the current story object\nwindow.currentStory = null;\n\n// --- IMPORT ---\nimportBtn.addEventListener(\"click\", async () => {\n    if (!fileInput.files.length) {\n        importStatus.textContent = \"Bitte zuerst eine JSON-Datei auswählen.\";\n        return;\n    }\n\n    const file = fileInput.files[0];\n    const fileUrl = URL.createObjectURL(file);\n\n    try {\n        story = await SaveLoad.loadFromJson(fileUrl, Scene, Story);\n        if(!story){\n            importStatus.textContent = \"Fehler beim Laden: Story konnte nicht geladen werden.\";\n            return;\n        }\n        window.currentStory = story;\n        importStatus.textContent = `\"${file.name}\" erfolgreich geladen (${story.scenes.size} Szenen).`;\n\n        if (typeof generateTreeAscii === \"function\") generateTreeAscii();\n        if (typeof startStory === \"function\") startStory();\n    } catch (err) {\n        importStatus.textContent = \"Fehler beim Laden: \" + err.message;\n    } finally {\n        URL.revokeObjectURL(fileUrl);\n    }\n});\n\n// --- EXPORT ---\nexportToJsonButton.addEventListener(\"click\", () => {\n    if (!window.currentStory) {\n        alert(\"Keine Story zum Exportieren vorhanden.\");\n        return;\n    }\n    SaveLoad.saveToJson(window.currentStory, \"story.json\");\n});\n\nexportToHtmlButton.addEventListener(\"click\", () => {\n    if (!window.currentStory) {\n        alert(\"Keine Story zum Exportieren vorhanden.\");\n        return;\n    }\n    SaveLoad.saveToHtml(window.currentStory, \"story.html\");\n});"],
  "mappings": "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",
  "names": ["Scene", "key", "text", "parent", "choices", "next", "choiceText", "c", "newText", "json", "parsedObject", "e", "scene", "choicesArray", "Story", "sceneClass", "scene", "parent", "sceneKey", "key", "depth", "current", "startScene", "result", "stack", "visited", "baseDepth", "children", "next", "child", "storyText", "choiceTexts", "text", "allScenesBelow", "i", "parsedJson", "SceneClass", "story", "value", "SaveLoad", "filename", "SceneClass", "StoryClass", "data", "response", "story", "jsonStory", "fileBlob", "link", "e", "viewerPart1", "viewerPart2", "jsonObject", "jsonText", "htmlText", "story", "Story", "Scene", "generateTreeAscii", "parentElement", "scenesWithDepth", "outputLines", "i", "key", "scene", "depth", "prefix", "d", "output", "addChoiceField", "container", "addScene", "sceneKey", "text", "choiceElements", "choices", "el", "next", "renderPreview", "choicesContainer", "notice", "html", "startStory", "renderScene", "area", "removeScene", "keyInput", "status", "event", "fileInput", "importBtn", "exportToJsonButton", "exportToHtmlButton", "importStatus", "file", "fileUrl", "SaveLoad", "err"]
}
