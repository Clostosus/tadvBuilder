{
  "version": 3,
  "sources": ["../src/builder/Scene.js", "../src/builder/Story.js", "../src/builder/SaveLoad.js", "../src/builder/main.js"],
  "sourcesContent": ["/**\n * Represents a single scene (node) in the story tree.\n * Each scene has narrative text, a list of choices (edges to other scenes),\n * and a reference to its parent scene. The root scene has a null parent.\n */\nexport default class Scene {\n    /**\n     * Root scene constructor.\n     * @param {string} key - Unique scene identifier.\n     * @param {string} text - Narrative text.\n     * @param {Scene|null} parent - Parent scene, or null for root.\n     * @param {Array<{text: string, next: string}>|Map<string, string>|null} choices - List of choices or null for leaf.\n     */\n    constructor(key, text = '', parent = null, choices = null)\n    {\n        this.key = key;\n        this.text = text;\n        this.parent = parent;\n        this.choices = new Map();\n\n        if (choices instanceof Map) {\n            for (const [next, choiceText] of choices) {\n                this.choices.set(next, choiceText);\n            }\n        } else if (Array.isArray(choices)) {\n            for (const c of choices) {\n                if (c.next && c.text) this.choices.set(c.next, c.text);\n            }\n        }\n    }\n\n\n    /**\n     * Adds a new choice (link) to another scene.\n     * @param {string} text - Description of the choice.\n     * @param {string} next - ID of the next scene.\n     * @returns {boolean} True if added successfully, false if duplicate key exists.\n     */\n    addChoice(text, next)\n    {\n        if (this.choices.has(next)) return false;\n        this.choices.set(next, text);\n        return true;\n    }\n\n    /**\n     * Updates the text of an existing choice.\n     * @param {string} next - Target scene ID.\n     * @param {string} newText - New description text.\n     * @returns {boolean} True if updated, false if not found.\n     */\n    updateChoice(next, newText) {\n        if (!this.choices.has(next)) return false;\n        this.choices.set(next, newText);\n        return true;\n    }\n\n    /**\n     * Removes a choice by its next key.\n     * @param {string} next - Target scene ID.\n     * @returns {boolean} True if removed, false if not found.\n     */\n    removeChoice(next) { return this.choices.delete(next); }\n\n    /**\n     * Returns all choices as an array of plain objects.\n     * @returns {Array<{text: string, next: string}>} List of choices.\n     */\n    getAllChoices()\n    {\n        return Array.from(this.choices, ([next, text]) => ({ text, next }));\n    }\n\n    /**\n     * Creates a new Scene instance from a JSON text.\n     * @returns {Scene} New Scene instance or null if parsing fails.\n     * @param {string} key\n     * @param {object|string} json\n     */\n    static fromJson(key,json)\n    {\n        if (!key || !json) return null;\n\n        let parsedObject = null;\n        // accept both raw string or parsed object\n        if (typeof json === 'string') {\n            try {\n                parsedObject = JSON.parse(json);\n            } catch (e) {\n                console.error(`Failed to parse JSON for scene ${key}: ${e}`);\n                return null;\n            }\n        } else if (typeof json === 'object') {\n            parsedObject = json;\n        } else {\n            console.error(`Failed to parse JSON for scene ${key}: Invalid JSON type`);\n            return null;\n        }\n        \n        if(!parsedObject.text || typeof parsedObject.text !== 'string'){\n            console.error(`Scene ${key} missing text property.`);\n            return null;\n        }\n\n        const scene = new Scene(key, parsedObject.text, null,[]);\n\n        // handle optional choices (leaf scenes may have none)\n        if (Array.isArray(parsedObject.choices)) {\n            for (const c of parsedObject.choices) {\n                if (!c || typeof c.text !== 'string' || typeof c.next !== 'string') continue;\n                scene.addChoice(c.text, c.next);\n            }\n        }\n\n        return scene;\n    }\n\n    /**\n     * Converts the scene into a plain JSON-compatible object.\n     * @returns {{text: string, choices: Array<{text: string, next: string}>}}\n     */\n    toJSON()\n    {\n        const choicesArray = [];\n        for (const [next, text] of this.choices.entries()) {\n            choicesArray.push({ text, next });\n        }\n        if(choicesArray.length === 0){\n            return { text: this.text };\n        }\n        return { text: this.text, choices: choicesArray };\n    }\n}\n\n/**\n * @typedef {Object} SceneRef\n * @property {Scene|null} scene - The referenced Scene instance, or null if missing.\n * @property {string} key - The scene key (ID)\n * @property {number} depth - Depth in the DFS traversal of the story tree, starting at 0 for the root scene.\n */", "/**\n * Represents the entire story as an object-oriented tree of scenes.\n * Controls all scenes and ensures proper parent-child relationships.\n * Each scene (except the root) must have exactly one parent.\n */\nexport default class Story {\n    /**\n     * @param {Class} sceneClass - Class representing a Scene object.\n     */\n    constructor(sceneClass)\n    {\n        this.sceneClass = sceneClass;\n        this.scenes = new Map(); // key -> Scene\n        this.root = null;        // start scene\n    }\n\n    /**\n     * Adds an existing Scene instance to the story.\n     * @param {Scene} scene - Scene object to add.\n     * @returns {boolean} True if added, false if duplicate Key.\n     */\n    addScene(scene)\n    {\n        if (!(scene instanceof this.sceneClass)) return false;\n        if (this.scenes.has(scene.key)) return false;\n\n        this.scenes.set(scene.key, scene);\n        if (!this.root) {\n            this.root = scene;\n            return true;\n        } // first scene becomes root\n\n        if (!scene.parent && this.root && this.scenes.size > 0) {\n            const parent = this.findParent(scene.key);\n            if (parent) {\n                scene.parent = parent;\n                parent.addChoice(scene.text || `to ${scene.key}`, scene.key);\n            } else {\n                this.root.addChoice(scene.text || `to ${scene.key}`, scene.key);\n                scene.parent = this.root;\n            }\n        }\n\n        // ensure parent linkage integrity\n        if (scene.parent && this.scenes.has(scene.parent.key)) {\n            const parent = this.scenes.get(scene.parent.key);\n            parent.addChoice(scene.text || `to ${scene.key}`, scene.key);\n        }\n\n        return true;\n    }\n\n    /**\n     * Finds the parent Scene whose choices reference the given scene key.\n     * @param {string} sceneKey - Key of the scene to find a parent for.\n     * @returns {Scene|null} The parent Scene, or null if not found.\n     */\n    findParent(sceneKey) {\n        for (const scene of this.scenes.values()) {\n            if (scene.choices instanceof Map && scene.choices.has(sceneKey)) {\n                return scene;\n            }\n        }\n        return null;\n    }\n\n\n    /**\n     * Retrieves a scene by key.\n     * @param {string} key\n     * @returns {Scene|null}\n     */\n    getScene(key) { return this.scenes.get(key) || null; }\n\n    /**\n     * Retrieves all scene references as array in depth-first order.\n     * Returns objects containing scene key, optional Scene instance, and depth.\n     * @returns {Array<SceneRef>}\n     */\n    getAllScenesDFS()\n    {\n        if (!this.root) return [];\n        /** @type {Array<SceneRef>} */\n        const result = [];\n        const stack = [];\n        stack.push({ scene: this.root, depth: 0 });\n\n        const visited = new Set();\n\n        while (stack.length > 0) {\n            const { scene, depth } = stack.pop();\n\n            if(visited.has(scene.key)){ continue; }\n            visited.add(scene.key);\n            result.push({ key: scene.key, scene: scene,depth: depth });\n\n            const children = [];\n            for (const [next] of scene.choices.entries()) {\n                const child = this.getScene(next);\n                if (child) {\n                    children.push(child);\n                }else {\n                    // Add missing referenced scene explicitly\n                    result.push({\n                        key: next,\n                        scene: null,\n                        depth: depth + 1\n                    });\n                }\n            }\n            // reverse order to get initial order\n            for (let i = children.length - 1; i >= 0; i--) {\n                stack.push({ scene: children[i], depth: depth + 1 });\n            }\n        }\n        return result;\n    }\n\n\n\n    /**\n     * Converts the entire story into a JSON-compatible structure.\n     * Each scene key maps to an object with `text` and `choices` array.\n     * @returns {Object<string, {text: string, choices: Array<{text: string, next: string}>}>}\n     */\n    toJSON()\n    {\n        const result = {};\n        for (const [key, scene] of this.scenes.entries()) {\n            result[key] = scene.toJSON();\n        }\n        return result;\n    }\n}", "export default class SaveLoad {\n    constructor() {\n        throw new Error('Static class');\n    }\n\n    /**\n     * Builds the story tree from plain JSON text.\n     * @param {string} filename\n     * @param {Object} SceneClass\n     * @param {Object} StoryClass\n     * @returns {Story | null | Promise<string>} Returns new story,null deserialization fails, or Promise<string> if loading fails.\n     */\n    static async loadFromJson(filename,SceneClass, StoryClass)\n    {\n        if (!filename || typeof filename !== 'string') {\n            return null;\n        }\n        let data = null;\n        try {\n            const response = await fetch(filename);\n            if (!response.ok) {\n                return null;\n            }\n            data = await response.json();\n        } catch (e) {\n            return null;\n        }\n        if (!data || typeof data !== 'object') { return null; }\n\n        const story = new StoryClass(SceneClass);\n\n        for (const [key, value] of Object.entries(data)) {\n            const scene = SceneClass.fromJson(key, value);\n            if (scene) {\n                story.addScene(scene);\n            }else{\n                console.warn(`Failed to load scene ${key}`);\n                return null;\n            }\n        }\n        if (story.scenes.size === 0) { return null; }\n        console.log(\"Story loaded from Json\");\n        return story;\n    }\n\n    /**\n     * Saves the story tree as JSON text.\n     * @param {Story} story\n     * @param {string} filename\n     * @returns {boolean | Promise<boolean>}\n     */\n    static async saveToJson(story, filename)\n    {\n        if (!story || !filename || typeof filename !== 'string') {\n            console.error(\"Ungültige Eingabeparameter in saveToJson: story = \", story, \", filename = \", filename);\n            return false;\n        }\n\n        const data = story.toJSON();\n        try {\n            let jsonStory = JSON.stringify(data)\n            const fileBlob = new Blob([jsonStory], { type: 'text/json' });\n\n            // Create a temporary link element\n            const link = document.createElement('a');\n            link.href = URL.createObjectURL(fileBlob);\n            link.download = filename;\n            // Programmatically click the link to trigger the download\n            link.click();\n            // Clean up the URL object\n            URL.revokeObjectURL(link.href);\n\n            console.log(\"Story saved to Json\");\n        }catch(e){\n            console.error(\"Failed to save story to Json:\" + e);\n            return false;\n        }\n        return true;\n    }\n}", "import Scene from './Scene.js';\nimport Story from \"./Story.js\";\nimport SaveLoad from \"./SaveLoad.js\";\n\n// const story = new Story();\nlet story = new Story(Scene);\n\n/**\n * Generates the story tree as an ASCII-style string.\n * Marks missing (unresolved) scenes explicitly.\n * @param {HTMLElement} parentElement Element inside which the output will be inserted.\n */\nfunction generateTreeAscii(parentElement = document.getElementById('tree-output'))\n{\n    if (!parentElement) return;\n    if (!story || !story.root) {\n        parentElement.textContent = '(noch kein Baum erstellt)';\n        return;\n    }\n\n    const scenesWithDepth = story.getAllScenesDFS();\n    const outputLines = [];\n\n    for (let i = 0; i < scenesWithDepth.length; i++) {\n        let { key, scene, depth } = scenesWithDepth[i];\n\n        // Tree-prefix (Indentation with ASCII)\n        let prefix = '';\n        for (let d = 0; d < depth; d++) {\n            prefix += (d === depth - 1) ? '|_ ' : '   ';\n        }\n        key = String(key); // ensure its string\n\n        if (scene === null) {\n            outputLines.push(prefix + '[' + key + ']' + \"(MISSING)\");\n        } else {\n            outputLines.push(prefix + key);\n        }\n    }\n    const output =  outputLines.join('\\n');\n    parentElement.textContent = output;\n}\n\n/**\n * Adds a new choice field to the choices container.\n * @returns void\n */\nfunction addChoiceField(parentElement = document.getElementById('choices-container'))\n{\n    const container = document.createElement('div');\n    container.className = 'choice-inputs';\n    container.innerHTML = `\n        <input type=\"text\" class=\"choice-text\" placeholder=\"Entscheidungstext\">\n        <input type=\"text\" class=\"choice-next\" placeholder=\"Nächste Szene (Schlüssel)\">\n      `;\n    parentElement.appendChild(container);\n}\n\n/**\n * Adds a new scene to the story.\n * @returns void\n */\nfunction addScene()\n{\n    const sceneKey = document.getElementById('scene-key').value.trim();\n    const text = document.getElementById('scene-text').value.trim();\n    if (!sceneKey || !text) return alert(\"Bitte Schlüssel und Text ausfüllen.\");\n\n    const choiceElements = document.querySelectorAll('.choice-inputs');\n    const choices = new Map();\n    choiceElements.forEach(el => {\n        const text = el.querySelector('.choice-text').value.trim();\n        const next = el.querySelector('.choice-next').value.trim();\n        if (text && next) choices.set(next, text);\n    });\n\n    story.addScene(new Scene(sceneKey, text, null, choices));\n    renderPreview(sceneKey);\n    generateTreeAscii();\n\n    // Eingabefelder leeren\n    document.getElementById('scene-key').value = \"\";\n    document.getElementById('scene-text').value = \"\";\n    const choicesContainer = document.getElementById('choices-container');\n    choicesContainer.innerHTML = `<div class=\"choice-inputs\">\n    <input type=\"text\" class=\"choice-text\" placeholder=\"Entscheidungstext\">\n    <input type=\"text\" class=\"choice-next\" placeholder=\"Nächste Szene (Schlüssel)\">\n  </div>`;\n\n    // Rückmeldung anzeigen\n    const notice = document.createElement('div');\n    notice.textContent = `✅ Szene '${sceneKey}' wurde gespeichert.`;\n    notice.style.backgroundColor = '#dcfce7';\n    notice.style.border = '1px solid #22c55e';\n    notice.style.color = '#166534';\n    notice.style.padding = '0.5rem 1rem';\n    notice.style.borderRadius = '6px';\n    notice.style.marginTop = '1rem';\n    notice.style.fontSize = '0.95rem';\n    const section = document.querySelectorAll('.section')[0];\n    section.appendChild(notice);\n    setTimeout(() => notice.remove(), 3000);\n}\n\nfunction renderPreview(key)\n{\n    const scene = story.getScene(key);\n    if (!scene) return;\n    let html = `<p><strong>${scene.key}</strong>: ${scene.text}</p>`;\n    for (const [next, text] of scene.choices.entries()) {\n        html += `<button disabled>${text} -> ${next}</button><br>`\n    }\n    document.getElementById('preview').innerHTML = html;\n}\n\nfunction startStory()\n{\n    if (!story.root) {\n        alert(\"Keine 'start'-Szene gefunden.\");\n        return;\n    }\n    renderScene(\"start\");\n}\n\nfunction renderScene(key)\n{\n    const area = document.getElementById('play-area');\n    const scene = story.getScene(key);\n    if (!scene) {\n        area.innerHTML = `<p><em>Szene '${key}' nicht gefunden.</em></p>`;\n        return;\n    }\n    let html = `<p><strong>${scene.key}</strong>: ${scene.text}</p>`;\n    for (const [next, text] of scene.choices.entries()) {\n        html += `<button onclick=\"renderScene('${next}')\">${text}</button><br>`\n    }\n    area.innerHTML = html;\n}\n\n// make functions available to HTML file\nwindow.addChoiceField = addChoiceField;\nwindow.addScene = addScene;\nwindow.startStory = startStory;\nwindow.renderTree = generateTreeAscii;\n// make helper functions available\nwindow.renderPreview = renderPreview;\nwindow.renderScene = renderScene;\n\n// === JSON Import/Export GUI ===\n\nconst fileInput = document.getElementById(\"json-file\");\nconst importBtn = document.getElementById(\"import-json\");\nconst exportBtn = document.getElementById(\"export-json\");\nconst importStatus = document.getElementById(\"import-status\");\n\n// Reference to the current story object\nwindow.currentStory = null;\n\n// --- IMPORT ---\nimportBtn.addEventListener(\"click\", async () => {\n    if (!fileInput.files.length) {\n        importStatus.textContent = \"Bitte zuerst eine JSON-Datei auswählen.\";\n        return;\n    }\n\n    const file = fileInput.files[0];\n    const fileUrl = URL.createObjectURL(file);\n\n    try {\n        story = await SaveLoad.loadFromJson(fileUrl, Scene, Story);\n        if(!story){\n            importStatus.textContent = \"Fehler beim Laden: Story konnte nicht geladen werden.\";\n            return;\n        }\n        window.currentStory = story;\n        importStatus.textContent = `\"${file.name}\" erfolgreich geladen (${story.scenes.size} Szenen).`;\n\n        if (typeof generateTreeAscii === \"function\") generateTreeAscii();\n        if (typeof startStory === \"function\") startStory();\n    } catch (err) {\n        importStatus.textContent = \"Fehler beim Laden: \" + err.message;\n    } finally {\n        URL.revokeObjectURL(fileUrl);\n    }\n});\n\n// --- EXPORT ---\nexportBtn.addEventListener(\"click\", () => {\n    if (!window.currentStory) {\n        alert(\"Keine Story zum Exportieren vorhanden.\");\n        return;\n    }\n    SaveLoad.saveToJson(window.currentStory, \"story_export.json\");\n});"],
  "mappings": "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",
  "names": ["Scene", "key", "text", "parent", "choices", "next", "choiceText", "c", "newText", "json", "parsedObject", "e", "scene", "choicesArray", "Story", "sceneClass", "scene", "parent", "sceneKey", "key", "result", "stack", "visited", "depth", "children", "next", "child", "SaveLoad", "filename", "SceneClass", "StoryClass", "data", "response", "story", "key", "value", "scene", "jsonStory", "fileBlob", "link", "e", "story", "Story", "Scene", "generateTreeAscii", "parentElement", "scenesWithDepth", "outputLines", "i", "key", "scene", "depth", "prefix", "output", "addChoiceField", "container", "addScene", "sceneKey", "text", "choiceElements", "choices", "el", "next", "renderPreview", "choicesContainer", "notice", "html", "startStory", "renderScene", "area", "fileInput", "importBtn", "exportBtn", "importStatus", "file", "fileUrl", "SaveLoad", "err"]
}
