{
  "version": 3,
  "sources": ["../src/builder/Scene.js", "../src/builder/Story.js", "../src/builder/SaveLoad.js", "../src/builder/StoryTreeRenderer.js", "../src/builder/main.js"],
  "sourcesContent": ["/**\n * Represents a single scene (node) in the story tree.\n * Each scene has narrative text, a list of choices (edges to other scenes),\n * and a reference to its parent scene. The root scene has a null parent.\n */\nexport default class Scene {\n    /**\n     * Root scene constructor.\n     * @param {string} key - Unique scene identifier.\n     * @param {string} text - Narrative text.\n     * @param {Scene|null} parent - Parent scene, or null for root.\n     * @param {Array<{text: string, next: string}>|Map<string, string>|null} choices - List of choices or null for leaf.\n     */\n    constructor(key, text = '', parent = null, choices = null)\n    {\n        this.key = key;\n        this.text = text;\n        this.parent = parent;\n        this.choices = new Map();\n\n        if (choices instanceof Map) {\n            for (const [next, choiceText] of choices) {\n                this.choices.set(next, choiceText);\n            }\n        } else if (Array.isArray(choices)) {\n            for (const c of choices) {\n                if (c.next && c.text) this.choices.set(c.next, c.text);\n            }\n        }\n    }\n\n\n    /**\n     * Adds a new choice (link) to another scene.\n     * @param {string} text - Description of the choice.\n     * @param {string} next - ID of the next scene.\n     * @returns {boolean} True if added successfully, false if duplicate key exists.\n     */\n    addChoice(text, next)\n    {\n        if (this.choices.has(next)) return false;\n        this.choices.set(next, text);\n        return true;\n    }\n\n    /**\n     * Updates the text of an existing choice.\n     * @param {string} next - Target scene ID.\n     * @param {string} newText - New description text.\n     * @returns {boolean} True if updated, false if not found.\n     */\n    updateChoice(next, newText) {\n        if (!this.choices.has(next)) return false;\n        this.choices.set(next, newText);\n        return true;\n    }\n\n    /**\n     * Removes a choice by its next key.\n     * @param {string} next - Target scene ID.\n     * @returns {boolean} True if removed, false if not found.\n     */\n    removeChoice(next) { return this.choices.delete(next); }\n\n    /**\n     * Returns all choices as an array of plain objects.\n     * @returns {Array<{text: string, next: string}>} List of choices.\n     */\n    getAllChoices()\n    {\n        return Array.from(this.choices, ([next, text]) => ({ text, next }));\n    }\n\n    /**\n     * Creates a new Scene instance from a JSON text.\n     * @returns {Scene | null} New Scene instance or null if parsing fails.\n     * @param {string} key\n     * @param {object|string} json\n     */\n    static fromJson(key,json)\n    {\n        if (!key || !json) return null;\n\n        let parsedObject = null;\n        // accept both raw string or parsed object\n        if (typeof json === 'string') {\n            try {\n                parsedObject = JSON.parse(json);\n            } catch (e) {\n                console.error(`Failed to parse JSON for scene ${key}: ${e}`);\n                return null;\n            }\n        } else if (typeof json === 'object') {\n            parsedObject = json;\n        } else {\n            console.error(`Failed to parse JSON for scene ${key}: Invalid JSON type`);\n            return null;\n        }\n        \n        if(!parsedObject.text || typeof parsedObject.text !== 'string'){\n            console.error(`Scene ${key} missing text property.`);\n            return null;\n        }\n\n        const scene = new Scene(key, parsedObject.text, null,[]);\n\n        // handle optional choices (leaf scenes may have none)\n        if (Array.isArray(parsedObject.choices)) {\n            for (const c of parsedObject.choices) {\n                if (!c || typeof c.text !== 'string' || typeof c.next !== 'string') continue;\n                scene.addChoice(c.text, c.next);\n            }\n        }\n\n        return scene;\n    }\n\n    /**\n     * Converts the scene into a plain JSON-compatible object.\n     * @returns {{text: string, choices: Array<{text: string, next: string}>}}\n     */\n    toJSON()\n    {\n        const choicesArray = [];\n        for (const [next, text] of this.choices.entries()) {\n            choicesArray.push({ text, next });\n        }\n        if(choicesArray.length === 0){\n            return { text: this.text };\n        }\n        return { text: this.text, choices: choicesArray };\n    }\n}\n\n/**\n * @typedef {Object} SceneRef\n * @property {Scene|null} scene - The referenced Scene instance, or null if missing.\n * @property {string} key - The scene key (ID)\n * @property {number} depth - Depth in the DFS traversal of the story tree, starting at 0 for the root scene.\n */", "/**\n * Represents the entire story as an object-oriented tree of scenes.\n * Controls all scenes and ensures proper parent-child relationships.\n * Each scene (except the root) must have exactly one parent.\n */\nexport default class Story {\n    /**\n     * @constructor\n     * @param {Class} sceneClass - Class representing a Scene.\n     */\n    constructor(sceneClass)\n    {\n        this.sceneClass = sceneClass;\n        this.scenes = new Map(); // key -> Scene\n        this.root = null;        // start scene\n    }\n\n    /**\n     * Adds an existing Scene instance to the story.\n     * @param {Scene} scene - Scene object to add.\n     * @returns {boolean} True if added, false if duplicate Key.\n     */\n    addScene(scene)\n    {\n        if (!(scene instanceof this.sceneClass)) return false;\n        if (this.scenes.has(scene.key)) return false;\n\n        this.scenes.set(scene.key, scene);\n        if (!this.root) {\n            this.root = scene;\n            return true;\n        } // first scene becomes root\n\n        if (!scene.parent && this.root && this.scenes.size > 0) {\n            const parent = this.findParent(scene.key);\n            if (parent) {\n                scene.parent = parent;\n                parent.addChoice(scene.text || `to ${scene.key}`, scene.key);\n            } else {\n                this.root.addChoice(scene.text || `to ${scene.key}`, scene.key);\n                scene.parent = this.root;\n            }\n        }\n\n        // ensure parent linkage integrity\n        if (scene.parent && this.scenes.has(scene.parent.key)) {\n            const parent = this.scenes.get(scene.parent.key);\n            parent.addChoice(scene.text || `to ${scene.key}`, scene.key);\n        }\n\n        return true;\n    }\n\n    /**\n     * Finds the parent Scene whose choices reference the given scene key.\n     * @param {string} sceneKey - Key of the scene to find a parent for.\n     * @returns {Scene|null} The parent Scene, or null if not found.\n     */\n    findParent(sceneKey) {\n        for (const scene of this.scenes.values()) {\n            if (scene.choices instanceof Map && scene.choices.has(sceneKey)) {\n                return scene;\n            }\n        }\n        return null;\n    }\n\n\n    /**\n     * Retrieves a scene by key.\n     * @param {string} key\n     * @returns {Scene|null}\n     */\n    getScene(key) { return this.scenes.get(key) || null; }\n\n    /**\n     * Depth of a scene relative to the root scene.\n     * @param {Map<string, Scene>} scenes - The map of scenes in the story (Key -> Scene).\n     * @param {Scene} scene - The scene whose depth needs to be calculated.\n     * @returns {number} The depth of the scene, -1 if the scene is not found.\n     */\n    static getSceneDepth(scenes, scene) {\n        if(! scenes.has(scene.key)){ return -1; }\n\n        let depth = 0;\n        let current = scene;\n        while (current && current.parent) {\n            depth++;\n            current = current.parent;\n        }\n        return depth;\n    }\n\n    /**\n     * Retrieves all scene references below start scene as array in depth-first order.\n     * starting from the given scene (defaults to root).\n     * @param {Story} story - The story instance containing the scenes.\n     * @param {Scene} [startScene=this.root]\n     * @returns {Array<SceneRef>} Array of { key, scene, depth }\n     */\n    static getScenesDFS(story, startScene = this.root)\n    {\n        if (!startScene) return [];\n        /** @type {Array<SceneRef>} */\n        const result = [];\n        const stack = [];\n        const visited = new Set();\n\n        let baseDepth = 0;\n        if (startScene !== story.root) {\n            baseDepth = Story.getSceneDepth(story.scenes,startScene);\n        }\n        stack.push({ scene: startScene, depth: baseDepth });\n\n        while (stack.length > 0) {\n            const { scene, depth } = stack.pop();\n\n            if(visited.has(scene.key)){ continue; }\n            visited.add(scene.key);\n            result.push({ key: scene.key, scene: scene,depth: depth });\n\n            const children = [];\n            for (const [next] of scene.choices.entries()) {\n                const child = story.getScene(next);\n                if (child) {\n                    children.push(child);\n                }else {\n                    result.push({key: next,scene: null,depth: depth + 1});\n                }\n            }\n\n            // reverse order to get initial order\n            for (let i = children.length - 1; i >= 0; i--) {\n                stack.push({ scene: children[i], depth: depth + 1 });\n            }\n        }\n        return result;\n    }\n\n    /* Content means the story text of the scene itself, and the description texts of the choices in this scene.\n     * @param {string} key\n     * @param {string} storyText\n     * @param {Map<string,string>} choiceTexts(<key,text>)\n     * @return {boolean} true if content was edited, false if not found\n     */\n    editSceneContent(key, storyText, choiceTexts = null)\n    {\n        let scene = this.scenes.get(key);\n        if(!scene){\n            console.warn(`Scene ${key} not found`);\n            return false;\n        }\n        if(storyText){\n            scene.text = storyText;\n        }\n        if(choiceTexts){\n            for (const [next, text] of choiceTexts.entries()) {\n                if(! scene.updateChoice(next, text)) { console.warn(`Failed to edit choice ${next} in scene ${key}`); }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Deletes a scene by key. Also deletes parent scene choices referencing this scene\n     * and recursively removes child scenes of this scene.\n     * @param {string} key\n     * @returns {boolean} True if found and deleted, else False\n     */\n    removeScene(key){\n        const scene = this.scenes.get(key);\n        if(!scene){\n            console.warn(`Scene ${key} not found`);\n            return false;\n        }\n\n        if(scene.parent){ scene.parent.removeChoice(scene.key); }\n\n        // Get all scenes below this scene (inclusive this one)\n        const allScenesBelow = Story.getScenesDFS(this, scene);\n\n        // in dfs order, parents come before children\n        // To be sure that child scenes are removed before parent, we use a reverse loop:\n        for (let i = allScenesBelow.length - 1; i >= 0; i--) {\n            const { key } = allScenesBelow[i];\n            this.scenes.delete(key);\n        }\n        return true;\n    }\n\n    /**\n     * Converts the entire story into a JSON-compatible structure.\n     * Each scene key maps to an object with `text` and `choices` array.\n     * @returns {Object<string, {text: string, choices: Array<{text: string, next: string}>}>}\n     */\n    toJSON()\n    {\n        const result = {};\n        for (const [key, scene] of this.scenes.entries()) {\n            result[key] = scene.toJSON();\n        }\n        return result;\n    }\n\n    /**\n     * Creates a new Story instance from a JSON Object.\n     * @param {Object} parsedJson\n     * @param {Class} SceneClass\n     * @returns {Story | null} New Scene instance or null if parsing fails.\n     */\n    static fromJson(parsedJson, SceneClass) {\n        if (!parsedJson || typeof parsedJson !== 'object') { return null; }\n        if (typeof SceneClass.fromJson !== 'function') {\n            console.warn('SceneClass has no method called: fromJson');\n            return null;\n        }\n\n        let story = new Story(SceneClass);\n        for (const [key, value] of Object.entries(parsedJson)) {\n            const scene = SceneClass.fromJson(key, value);\n            if (scene) {\n                story.addScene(scene);\n            }else{\n                console.warn(`Failed to load scene ${key}`);\n                return null;\n            }\n        }\n        if (story.scenes.size === 0) {\n            console.warn('No scenes found in JSON');\n            return null;\n        }\n        return story;\n    }\n}", "export default class SaveLoad {\n    constructor() {\n        throw new Error('Static class');\n    }\n\n    /**\n     * Builds the story tree from plain JSON text.\n     * @param {string} filename\n     * @param {Class} SceneClass\n     * @param {Class} StoryClass\n     * @returns {Story | null | Promise<string>} Returns new story,null deserialization fails, or Promise<string> if loading fails.\n     */\n    static async loadFromJson(filename,SceneClass, StoryClass)\n    {\n        if (!filename || typeof filename !== 'string') {\n            return null;\n        }\n        let data = null;\n        try {\n            const response = await fetch(filename);\n            if (!response.ok) {\n                return null;\n            }\n            data = await response.json();\n        } catch (e) {\n            return null;\n        }\n\n        if (typeof StoryClass.fromJson !== 'function') {\n            console.warn('StoryClass has no method called: fromJson');\n            return null;\n        }\n        return StoryClass.fromJson(data,SceneClass);\n    }\n\n    /**\n     * Saves the story tree as JSON text.\n     * @param {Story} story\n     * @param {string} filename\n     * @returns {boolean | Promise<boolean>}\n     */\n    static async saveToJson(story, filename)\n    {\n        if (!story || !filename || typeof filename !== 'string') {\n            console.error(\"Ungültige Eingabeparameter in saveToJson: story = \", story, \", filename = \", filename);\n            return false;\n        }\n\n        const data = story.toJSON();\n        try {\n            let jsonStory = JSON.stringify(data)\n            const fileBlob = new Blob([jsonStory], { type: 'text/json' });\n\n            // Create a temporary link element\n            const link = document.createElement('a');\n            link.href = URL.createObjectURL(fileBlob);\n            link.download = filename;\n            // Programmatically click the link to trigger the download\n            link.click();\n            // Clean up the URL object\n            URL.revokeObjectURL(link.href);\n\n            console.log(\"Story saved to Json\");\n        }catch(e){\n            console.error(\"Failed to save story to Json:\" + e);\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Saves a story as an executable HTML/CSS/JS file with which the story can be played in a browser.\n     * @param {string} filename\n     * @param {Story} story\n     * @returns {boolean | Promise<boolean>}\n     */\n    static async saveToHtml(story, filename)\n    {\n        if (!story || !filename || typeof filename !== 'string') {\n            console.error(\"Ungültige Eingabeparameter in saveToHtml: story = \", story, \", filename = \", filename);\n            return false;\n        }\n\n        // base64 encoded viewer code parts, without encoding storing them as string without unintended escaping is hard\n        // ------------------------------------------- VIEWER TEMPLATE PART 1\n        const viewerPart1 = 'PCFET0NUWVBFIGh0bWw+CjxodG1sIGxhbmc9ImRlIj4KPGhlYWQ+CiAgICA8bWV0YSBjaGFyc2V0PSJVVEYtOCI+CiAgICA8dGl0bGU+U3RvcnktVmlld2VyPC90aXRsZT4KICAgIDxzdHlsZT4KICAgICAgICBib2R5IHsKICAgICAgICAgICAgZm9udC1mYW1pbHk6IHN5c3RlbS11aSwgc2Fucy1zZXJpZjsKICAgICAgICB9CiAgICAgICAgaDIgewogICAgICAgICAgICBjb2xvcjogIzBmMTcyYTsKICAgICAgICAgICAgbWFyZ2luLWJvdHRvbTogMC4yNXJlbTsKICAgICAgICB9CiAgICAgICAgI2dhbWUgewogICAgICAgICAgICBiYWNrZ3JvdW5kOiAjZjFmNWY5OwogICAgICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjY2JkNWUxOwogICAgICAgICAgICBwYWRkaW5nOiAxcmVtOwogICAgICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7CiAgICAgICAgICAgIG1hcmdpbjogMCBhdXRvOwogICAgICAgICAgICBtYXgtd2lkdGg6IDgwMHB4OwogICAgICAgICAgICB3aGl0ZS1zcGFjZTogcHJlLXdyYXA7CiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgNHB4IDEycHggcmdiYSgwLDAsMCwwLjA2KTsKICAgICAgICB9CiAgICAgICAgI2dhbWUgYnV0dG9uIHsKICAgICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogIzNiODJmNjsKICAgICAgICAgICAgd2lkdGg6IDEwMCU7CiAgICAgICAgICAgIGNvbG9yOiB3aGl0ZTsKICAgICAgICAgICAgYm9yZGVyOiBub25lOwogICAgICAgICAgICBwYWRkaW5nOiAwLjZyZW0gMXJlbTsKICAgICAgICAgICAgYm9yZGVyLXJhZGl1czogNnB4OwogICAgICAgICAgICBjdXJzb3I6IHBvaW50ZXI7CiAgICAgICAgICAgIG1hcmdpbi10b3A6IDAuNXJlbTsKICAgICAgICAgICAgZm9udC13ZWlnaHQ6IDUwMDsKICAgICAgICB9CiAgICA8L3N0eWxlPgo8L2hlYWQ+Cjxib2R5Pgo8ZGl2IGlkPSJnYW1lIj48L2Rpdj4KCjxzY3JpcHQ+CiAgICBjb25zdCBzdG9yeSA9IHsKICAgICAgICAvLyBJTlNFUlQgSlNPTiBTVE9SWSBIRVJFCg==';\n        // ------------------------------------------- VIEWER TEMPLATE PART 2\n        const viewerPart2 = 'ICAgIH07CgogICAgZnVuY3Rpb24gc2hvd1NjZW5lKGtleSkKICAgIHsKICAgICAgICBjb25zdCBzY2VuZSA9IHN0b3J5W2tleV07CiAgICAgICAgaWYgKCFzY2VuZSkgcmV0dXJuOwoKICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgiZ2FtZSIpOwogICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSAiIjsgLy8gZGVsZXRlIHByZXZpb3VzIGNvbnRlbnQvc2NlbmUKCiAgICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJoMiIpOwogICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0ga2V5OyBjb250YWluZXIuYXBwZW5kQ2hpbGQodGl0bGUpOwoKICAgICAgICBjb25zdCB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgicCIpOwogICAgICAgIHRleHQudGV4dENvbnRlbnQgPSBzY2VuZS50ZXh0OyBjb250YWluZXIuYXBwZW5kQ2hpbGQodGV4dCk7CgogICAgICAgIGlmICghc2NlbmUuY2hvaWNlcyB8fCBzY2VuZS5jaG9pY2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuOwoKICAgICAgICBmb3IgKGNvbnN0IGMgb2Ygc2NlbmUuY2hvaWNlcykgewogICAgICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCJidXR0b24iKTsKICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gYy50ZXh0OwogICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigiY2xpY2siLCAoKSA9PiBzaG93U2NlbmUoYy5uZXh0KSk7CiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChidXR0b24pOwogICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiYnIiKSk7CiAgICAgICAgfQogICAgfQoKICAgIHNob3dTY2VuZSgic3RhcnQiKTsKPC9zY3JpcHQ+CjwvYm9keT4KPC9odG1sPg==';\n\n        const jsonObject = story.toJSON();\n        let jsonText = JSON.stringify(jsonObject);\n        jsonText = jsonText.slice(1,-1)\n\n        try {\n            const htmlText = window.atob(viewerPart1) + jsonText + window.atob(viewerPart2);\n            const fileBlob = new Blob([htmlText], { type: 'text/html' });\n\n            // Create a temporary link element\n            const link = document.createElement('a');\n            link.href = URL.createObjectURL(fileBlob);\n            link.download = filename;\n            // Programmatically click the link to trigger the download\n            link.click();\n            // Clean up the URL object\n            URL.revokeObjectURL(link.href);\n\n            console.log(\"Story saved to Html\");\n        }catch(e){\n            console.error(\"Failed to save story to Json:\" + e);\n            return false;\n        }\n        return true;\n    }\n}", "import Story from \"./Story.js\";\n\nexport default class StoryTreeRenderer {\n    /**\n     * Generates the story tree as an ASCII-style string.\n     * Marks missing (unresolved) scenes explicitly.\n     * @param {Story} story - The story object containing the scenes.\n     * @param {HTMLElement} parentElement Element inside which the output will be inserted.\n     */\n    static generateTreeAscii(story,parentElement = document.getElementById('tree-output')) {\n        console.log(\"StoryTreeRenderer.generateTreeAscii. Parent: \" + parentElement.id + \" Story: \" + story.root.key);\n        if (!parentElement) return;\n        if (!story || !story.root) {\n            parentElement.textContent = '(noch kein Baum erstellt)';\n            return;\n        }\n\n        const scenesWithDepth = Story.getScenesDFS(story,story.root);\n        const outputLines = [];\n        for (let i = 0; i < scenesWithDepth.length; i++) {\n            let { key, scene, depth } = scenesWithDepth[i];\n\n            // Tree-prefix (Indentation with ASCII)\n            let prefix = '';\n            for (let d = 0; d < depth; d++) {\n                prefix += (d === depth - 1) ? '|_ ' : '   ';\n            }\n            key = String(key); // ensure its string\n\n            if (scene === null) {\n                outputLines.push(prefix + '[' + key + ']' + \"(MISSING)\");\n            } else {\n                outputLines.push(prefix + key);\n            }\n        }\n        const output = outputLines.join('\\n');\n        parentElement.textContent = output;\n    }\n}", "import Scene from './Scene.js';\nimport Story from \"./Story.js\";\nimport SaveLoad from \"./SaveLoad.js\";\nimport StoryTreeRenderer from './StoryTreeRenderer.js';\n\nlet story = new Story(Scene);\n\n/**\n * Displays a temporary feedback message in the UI.\n * @param {string} message - The message to display.\n * @param {HTMLElement} targetElement - The HTML element where the message will be added.\n * @param {boolean} isSuccess - Determines if the message is a success or error.\n * @param {string} mode - Determines how the message is handled ('create' or 'set').\n */\nfunction showFeedback(message, targetElement, isSuccess, mode = 'create') {\n    if (!targetElement) return;\n\n    const feedbackClass = isSuccess ? 'feedback-success' : 'feedback-error';\n\n    if (mode === 'create') {\n        const notice = document.createElement('div');\n        notice.textContent = message;\n        notice.classList.add('feedback', feedbackClass); // CSS-Klasse hinzufügen\n        targetElement.appendChild(notice);\n        setTimeout(() => notice.remove(), 3000);\n    } else if (mode === 'set') {\n        targetElement.textContent = message;\n        targetElement.classList.add('feedback', feedbackClass); // CSS-Klasse hinzufügen\n    }\n}\n\n/**\n * Adds a new choice field to the choices container.\n * @returns void\n */\nfunction addChoiceField()\n{\n    const parentElement = document.getElementById('choices-container');\n    if (!parentElement) {\n        console.error('parentElement is not found.');\n        return;\n    }\n\n    const container = document.createElement('div');\n    container.className = 'choice-inputs';\n    container.innerHTML = `\n        <input type=\"text\" class=\"choice-text\" placeholder=\"Entscheidungstext\">\n        <input type=\"text\" class=\"choice-next\" placeholder=\"Nächste Szene (Schlüssel)\">\n      `;\n    parentElement.appendChild(container);\n}\n\n/**\n * Adds a new scene to the story.\n * @returns void\n */\nfunction addScene()\n{\n    const sceneKey = document.getElementById('scene-key').value.trim();\n    const text = document.getElementById('scene-text').value.trim();\n    const editorSection = document.getElementById('sceneEditor');\n\n    if (!sceneKey || !text) {\n        showFeedback(\"Bitte Schlüssel und Text ausfüllen.\", editorSection, false);\n        return;\n    }\n\n    const choiceElements = document.querySelectorAll('.choice-inputs');\n    const choices = new Map();\n    choiceElements.forEach(el => {\n        const text = el.querySelector('.choice-text').value.trim();\n        const next = el.querySelector('.choice-next').value.trim();\n        if (text && next) choices.set(next, text);\n    });\n\n    if(! story.addScene(new Scene(sceneKey, text, null, choices))){\n        showFeedback(\"Scene could not be added to story, key already exists.\", editorSection, false);\n        return;\n    }\n    renderScene(sceneKey);\n    StoryTreeRenderer.generateTreeAscii(story);\n\n    // Eingabefelder leeren\n    document.getElementById('scene-key').value = \"\";\n    document.getElementById('scene-text').value = \"\";\n    const choicesContainer = document.getElementById('choices-container');\n    choicesContainer.innerHTML = `<div class=\"choice-inputs\">\n    <input type=\"text\" class=\"choice-text\" placeholder=\"Entscheidungstext\">\n    <input type=\"text\" class=\"choice-next\" placeholder=\"Nächste Szene (Schlüssel)\">\n    </div>`;\n\n    showFeedback(`Szene wurde gespeichert.`, editorSection, true)\n}\n\nfunction startStory()\n{\n    if (!story.root) {\n        alert(\"Keine 'start'-Szene gefunden.\");\n        return;\n    }\n    renderScene(\"start\");\n}\n\nfunction renderScene(key)\n{\n    const area = document.getElementById('play-area');\n    const scene = story.getScene(key);\n    area.innerHTML = ''; // clear previous content\n\n    if (!scene) {\n        const errorMessage = document.createElement('p');\n        const em = document.createElement('em');\n        em.textContent = \"Szene \\'\" + key + \"' nicht gefunden.\";\n        errorMessage.appendChild(em);\n        area.textContent = '';  // Clear previous content\n        area.appendChild(errorMessage);\n        return;\n    }\n\n    const sceneTitle = document.createElement('p');\n    const sceneKeyStrong = document.createElement('strong');\n    sceneKeyStrong.textContent = key;\n    sceneTitle.append(sceneKeyStrong, \": \" + scene.text);\n\n    area.appendChild(sceneTitle);\n\n    for (const [next, text] of scene.choices.entries()) {\n        const button = document.createElement('button');\n        button.textContent = text;\n        button.onclick = () => renderScene(next);\n        area.appendChild(button);\n        area.appendChild(document.createElement('br'));\n    }\n}\n\nfunction editScene() {\n    const keyInput = document.getElementById(\"scene-key\");\n    const status = document.getElementById(\"scene-status\");\n    const textInput = document.getElementById(\"scene-text\");\n    const choicesContainer = document.getElementById(\"choices-container\");\n    const key = keyInput.value.trim();\n    const text = textInput.value.trim();\n\n    if(!key){\n        showFeedback(\"Bitte gib den Schlüssel der zu bearbeitenden Szene ein.\", status, false);\n        return;\n    }\n\n    let choices = new Map();\n    for (const el of choicesContainer.children) {\n        if(! el.classList.contains('choice-inputs')) continue;\n\n        let choiceTextInput = el.querySelector(\".choice-text\");\n        let choiceKeyInput  = el.querySelector(\".choice-next\");\n\n        if(! choiceTextInput || ! choiceKeyInput\n            || ! (choiceTextInput instanceof HTMLInputElement) || ! (choiceKeyInput instanceof HTMLInputElement)) {\n            console.log(\"Error in editScene: Invalid choice input elements. Skipping choice.\");\n        }\n        choices.set(choiceKeyInput.value.trim(),choiceTextInput.value.trim());\n    }\n\n    let success = story.editSceneContent(key, text, choices);\n    if(success){\n        renderScene(key);\n        showFeedback(`Szene wurde erfolgreich bearbeitet.`, status, true);\n    }\n}\n\nfunction removeScene(){\n    const keyInput = document.getElementById(\"scene-key\");\n    const key = keyInput.value.trim();\n    const status = document.getElementById(\"scene-status\");\n\n    if (!key) {\n        showFeedback(\"Bitte gib den Schlüssel der zu löschenden Szene ein.\", status, false);\n        return;\n    }\n    if(! confirm(`Soll die Szene \"${key}\" wirklich gelöscht werden?`)) return;\n\n    const success = story.removeScene(key);\n    if(! success){\n        showFeedback(`Keine Szene mit dem Schlüssel \"${key}\" gefunden.`, status, false);\n        return;\n    }\n\n    renderScene(story.root.key);\n    showFeedback(`Szene \"${key}\" wurde erfolgreich gelöscht.`, status, true);\n    keyInput.value = \"\";\n    document.getElementById(\"scene-text\").value = \"\";\n    StoryTreeRenderer.generateTreeAscii(story);\n}\n\n/**\n * Imports a story from a JSON file.\n * @returns void\n */\nasync function importStory() {\n    const fileInput = document.getElementById(\"json-file\");\n    const importStatus = document.getElementById(\"import-status\");\n    if (!fileInput.files.length) {\n        showFeedback(\"Bitte zuerst eine JSON-Datei auswählen.\", importStatus, false);\n        return;\n    }\n\n    const file = fileInput.files[0];\n    const fileUrl = URL.createObjectURL(file);\n\n    try {\n        story = await SaveLoad.loadFromJson(fileUrl, Scene, Story);\n        if(!story){\n            importStatus.textContent = \"Fehler beim Laden: Story konnte nicht geladen werden.\";\n            return;\n        }\n        showFeedback(`\"${file.name}\" erfolgreich geladen (${story.scenes.size} Szenen).`, importStatus, true);\n\n        StoryTreeRenderer.generateTreeAscii(story);\n        startStory();\n    } catch (err) {\n        showFeedback(\"Fehler beim Laden: \" + err.message, importStatus, false);\n    } finally {\n        URL.revokeObjectURL(fileUrl);\n    }\n}\n\n/**\n * Exports the current story to a JSON file.\n * @returns void\n */\nfunction exportToJson() {\n    if (!story) {\n        showFeedback(\"No story available to export.\", document.getElementById(\"import-status\"), false);\n        return;\n    }\n    let success = SaveLoad.saveToJson(story, \"story.json\");\n    if(success) showFeedback(\"Story successfully exported to JSON.\", document.getElementById(\"import-status\"), true);\n}\n\n/**\n * Exports the current story to an HTML file.\n * @returns void\n */\nfunction exportToHtml() {\n    if (!story) {\n        showFeedback(\"No story available to export.\", document.getElementById(\"import-status\"), false);\n        return;\n    }\n    let success = SaveLoad.saveToHtml(story, \"story.html\");\n    if(success) showFeedback(\"Story successfully exported to HTML.\", document.getElementById(\"import-status\"), true);\n}\n\n// make helper functions available for onclick to HTML file\nwindow.renderScene = renderScene;\nwindow.removeScene = removeScene;\n\n// Register functions\nwindow.addEventListener(\"DOMContentLoaded\", () => {\n    console.log(\"page is fully loaded\");\n    document.getElementById('add-choice-field').addEventListener('click', addChoiceField);\n    document.getElementById('add-scene').addEventListener('click', addScene);\n    document.getElementById('remove-scene').addEventListener('click', removeScene);\n    document.getElementById('edit-scene').addEventListener('click', editScene);\n\n    document.getElementById('start-story').addEventListener('click', startStory);\n    document.getElementById(\"btn-ascii-tree-refresh\").addEventListener(\"click\", () => {\n        StoryTreeRenderer.generateTreeAscii(story);\n    });\n\n    // --- JSON Import/Export Button Events ---\n    document.getElementById(\"import-json\").addEventListener(\"click\", importStory);\n    document.getElementById(\"export-json\").addEventListener(\"click\", exportToJson);\n    document.getElementById(\"export-html\").addEventListener(\"click\", exportToHtml);\n});"],
  "mappings": "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",
  "names": ["Scene", "key", "text", "parent", "choices", "next", "choiceText", "newText", "json", "parsedObject", "e", "scene", "choicesArray", "Story", "sceneClass", "scene", "parent", "sceneKey", "key", "scenes", "depth", "current", "story", "startScene", "result", "stack", "visited", "baseDepth", "children", "next", "child", "i", "storyText", "choiceTexts", "text", "allScenesBelow", "parsedJson", "SceneClass", "value", "SaveLoad", "filename", "SceneClass", "StoryClass", "data", "response", "story", "jsonStory", "fileBlob", "link", "e", "viewerPart1", "viewerPart2", "jsonObject", "jsonText", "htmlText", "StoryTreeRenderer", "story", "parentElement", "scenesWithDepth", "Story", "outputLines", "i", "key", "scene", "depth", "prefix", "d", "output", "story", "Story", "Scene", "showFeedback", "message", "targetElement", "isSuccess", "mode", "feedbackClass", "notice", "addChoiceField", "parentElement", "container", "addScene", "sceneKey", "text", "editorSection", "choiceElements", "choices", "el", "next", "renderScene", "StoryTreeRenderer", "choicesContainer", "startStory", "key", "area", "scene", "errorMessage", "em", "sceneTitle", "sceneKeyStrong", "button", "editScene", "keyInput", "status", "textInput", "choiceTextInput", "choiceKeyInput", "removeScene", "importStory", "fileInput", "importStatus", "file", "fileUrl", "SaveLoad", "err", "exportToJson", "exportToHtml"]
}
